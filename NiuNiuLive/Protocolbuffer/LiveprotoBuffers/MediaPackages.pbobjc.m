// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MediaPackages.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "MediaPackages.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - MediaPackagesRoot

@implementation MediaPackagesRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - MediaPackagesRoot_FileDescriptor

static GPBFileDescriptor *MediaPackagesRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"live"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum MediaPackageConst

GPBEnumDescriptor *MediaPackageConst_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "MediaPackageConstZero\000MediaPackageConstM"
        "tu\000";
    static const int32_t values[] = {
        MediaPackageConst_MediaPackageConstZero,
        MediaPackageConst_MediaPackageConstMtu,
    };
    static const char *extraTextFormatInfo = "\002\000\025\000\001\022b\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MediaPackageConst)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MediaPackageConst_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MediaPackageConst_IsValidValue(int32_t value__) {
  switch (value__) {
    case MediaPackageConst_MediaPackageConstZero:
    case MediaPackageConst_MediaPackageConstMtu:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MediaPackageMediaType

GPBEnumDescriptor *MediaPackageMediaType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "MediaPackageMediaTypeUnknown\000MediaPackag"
        "eMediaTypeVideo\000MediaPackageMediaTypeAud"
        "io\000";
    static const int32_t values[] = {
        MediaPackageMediaType_MediaPackageMediaTypeUnknown,
        MediaPackageMediaType_MediaPackageMediaTypeVideo,
        MediaPackageMediaType_MediaPackageMediaTypeAudio,
    };
    static const char *extraTextFormatInfo = "\003\000\034\000\001\032\000\002\032\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MediaPackageMediaType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MediaPackageMediaType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MediaPackageMediaType_IsValidValue(int32_t value__) {
  switch (value__) {
    case MediaPackageMediaType_MediaPackageMediaTypeUnknown:
    case MediaPackageMediaType_MediaPackageMediaTypeVideo:
    case MediaPackageMediaType_MediaPackageMediaTypeAudio:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum H264FrameType

GPBEnumDescriptor *H264FrameType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "H264FrameTypeUnknown\000H264FrameTypeSps\000H2"
        "64FrameTypePps\000H264FrameTypeI\000H264FrameT"
        "ypeB\000H264FrameTypeP\000";
    static const int32_t values[] = {
        H264FrameType_H264FrameTypeUnknown,
        H264FrameType_H264FrameTypeSps,
        H264FrameType_H264FrameTypePps,
        H264FrameType_H264FrameTypeI,
        H264FrameType_H264FrameTypeB,
        H264FrameType_H264FrameTypeP,
    };
    static const char *extraTextFormatInfo = "\006\000\024\000\001\016b\000\002\016b\000\003\016\000\004\016\000\005\016\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(H264FrameType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:H264FrameType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL H264FrameType_IsValidValue(int32_t value__) {
  switch (value__) {
    case H264FrameType_H264FrameTypeUnknown:
    case H264FrameType_H264FrameTypeSps:
    case H264FrameType_H264FrameTypePps:
    case H264FrameType_H264FrameTypeI:
    case H264FrameType_H264FrameTypeB:
    case H264FrameType_H264FrameTypeP:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MediaPackageCodecType

GPBEnumDescriptor *MediaPackageCodecType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "MediaPackageCodecTypeUnknown\000MediaPackag"
        "eCodecTypeH264\000MediaPackageCodecTypeAac\000";
    static const int32_t values[] = {
        MediaPackageCodecType_MediaPackageCodecTypeUnknown,
        MediaPackageCodecType_MediaPackageCodecTypeH264,
        MediaPackageCodecType_MediaPackageCodecTypeAac,
    };
    static const char *extraTextFormatInfo = "\003\000\034\000\001\031\000\002\026b\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MediaPackageCodecType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MediaPackageCodecType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MediaPackageCodecType_IsValidValue(int32_t value__) {
  switch (value__) {
    case MediaPackageCodecType_MediaPackageCodecTypeUnknown:
    case MediaPackageCodecType_MediaPackageCodecTypeH264:
    case MediaPackageCodecType_MediaPackageCodecTypeAac:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - MediaPackage

@implementation MediaPackage

@dynamic mediaType;
@dynamic codecType;
@dynamic h264FrameType;
@dynamic roomId;
@dynamic frameId;
@dynamic packageId;
@dynamic hasRemain;
@dynamic width;
@dynamic height;
@dynamic timestamp;
@dynamic totalSize;
@dynamic size;
@dynamic data_p;

typedef struct MediaPackage__storage_ {
  uint32_t _has_storage_[1];
  MediaPackageMediaType mediaType;
  MediaPackageCodecType codecType;
  H264FrameType h264FrameType;
  int32_t width;
  int32_t height;
  int32_t totalSize;
  int32_t size;
  NSString *roomId;
  NSData *data_p;
  int64_t frameId;
  int64_t packageId;
  int64_t timestamp;
} MediaPackage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mediaType",
        .dataTypeSpecific.enumDescFunc = MediaPackageMediaType_EnumDescriptor,
        .number = MediaPackage_FieldNumber_MediaType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MediaPackage__storage_, mediaType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "codecType",
        .dataTypeSpecific.enumDescFunc = MediaPackageCodecType_EnumDescriptor,
        .number = MediaPackage_FieldNumber_CodecType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MediaPackage__storage_, codecType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "h264FrameType",
        .dataTypeSpecific.enumDescFunc = H264FrameType_EnumDescriptor,
        .number = MediaPackage_FieldNumber_H264FrameType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MediaPackage__storage_, h264FrameType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = MediaPackage_FieldNumber_RoomId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MediaPackage__storage_, roomId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "frameId",
        .dataTypeSpecific.className = NULL,
        .number = MediaPackage_FieldNumber_FrameId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MediaPackage__storage_, frameId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "packageId",
        .dataTypeSpecific.className = NULL,
        .number = MediaPackage_FieldNumber_PackageId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(MediaPackage__storage_, packageId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hasRemain",
        .dataTypeSpecific.className = NULL,
        .number = MediaPackage_FieldNumber_HasRemain,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "width",
        .dataTypeSpecific.className = NULL,
        .number = MediaPackage_FieldNumber_Width,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(MediaPackage__storage_, width),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.className = NULL,
        .number = MediaPackage_FieldNumber_Height,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(MediaPackage__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = MediaPackage_FieldNumber_Timestamp,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(MediaPackage__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalSize",
        .dataTypeSpecific.className = NULL,
        .number = MediaPackage_FieldNumber_TotalSize,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(MediaPackage__storage_, totalSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = MediaPackage_FieldNumber_Size,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(MediaPackage__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = MediaPackage_FieldNumber_Data_p,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(MediaPackage__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MediaPackage class]
                                     rootClass:[MediaPackagesRoot class]
                                          file:MediaPackagesRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MediaPackage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\001\t\000\002\t\000\003\r\000\004\006\000\005\007\000\006\t\000\007\t\000\013\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MediaPackage_MediaType_RawValue(MediaPackage *message) {
  GPBDescriptor *descriptor = [MediaPackage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MediaPackage_FieldNumber_MediaType];
  return GPBGetMessageInt32Field(message, field);
}

void SetMediaPackage_MediaType_RawValue(MediaPackage *message, int32_t value) {
  GPBDescriptor *descriptor = [MediaPackage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MediaPackage_FieldNumber_MediaType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t MediaPackage_CodecType_RawValue(MediaPackage *message) {
  GPBDescriptor *descriptor = [MediaPackage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MediaPackage_FieldNumber_CodecType];
  return GPBGetMessageInt32Field(message, field);
}

void SetMediaPackage_CodecType_RawValue(MediaPackage *message, int32_t value) {
  GPBDescriptor *descriptor = [MediaPackage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MediaPackage_FieldNumber_CodecType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t MediaPackage_H264FrameType_RawValue(MediaPackage *message) {
  GPBDescriptor *descriptor = [MediaPackage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MediaPackage_FieldNumber_H264FrameType];
  return GPBGetMessageInt32Field(message, field);
}

void SetMediaPackage_H264FrameType_RawValue(MediaPackage *message, int32_t value) {
  GPBDescriptor *descriptor = [MediaPackage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MediaPackage_FieldNumber_H264FrameType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
